<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://cdn.babylonjs.com/recast.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
            
            #canvasZone {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
<body>
    <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
    <script>
        var canvas = document.getElementById("renderCanvas");

        var startRenderLoop = function (engine, canvas) {
            engine.runRenderLoop(function () {
                if (sceneToRender && sceneToRender.activeCamera) {
                    sceneToRender.render();
                }
            });
        }

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        ;
        /**
 *to do - start box with instruction
 *object that will end the game
 *ghosts dissapear after certain time
 * more ghosts with posibilities to appear for more randomness
 * other ghost texture
 * other maze texture?
 * check so ghost does not appear right after another ghost??
 * more night attmosphere
 */
function setupCameraForCollisions(camera) {
    camera.checkCollisions = true;
    camera.applyGravity = true;
    camera.ellipsoid = new BABYLON.Vector3(1, 1, 1);
} 

var createDefaultEngine = function () {
        return new BABYLON.Engine(canvas, true, {
            preserveDrawingBuffer: true,
            stencil: true,
            disableWebGL2Support: false
        });
    };

var ghostId = [];
var ghostPos = [];

var createScene = async function () {

    var scene = new BABYLON.Scene(engine);
    // https://doc.babylonjs.com/divingDeeper/cameras/camera_collisions
    scene.gravity = new BABYLON.Vector3(0, -0.5, 0);
    scene.collisionsEnabled = true;

    //var camera = new BABYLON.ArcRotateCamera("Camera", -Math.PI / 2, Math.PI / 2, 12, BABYLON.Vector3.Zero(), scene);
    var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(-4, 2.5, -6), scene);
    camera.setTarget(BABYLON.Vector3.Zero());
    camera.attachControl(canvas, true);
    setupCameraForCollisions(camera);



    //var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    //light.intensity = 0.7;

    var light = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(-1, 5, 0), scene);
	light.diffuse = new BABYLON.Color3(1, 1, 0.88, 0.45);

    //var ghostlight; excludedMeshes.push(sphere); --> to make ghosts more shiny and bring more light on them


    // Fog
    scene.fogMode = BABYLON.Scene.FOGMODE_EXP;
    scene.fogColor = new BABYLON.Color3(0.2, 0.2, 0.3);
    scene.fogDensity = 0.25;

    scene.clearColor = new BABYLON.Color3(0.2, 0.2, 0.3);
    scene.ambientColor = new BABYLON.Color3(0.6, 0.6, 0.6);

    const greenMaterial = new BABYLON.StandardMaterial('greenMat', scene);
    greenMaterial.diffuseColor = new BABYLON.Color3(0.02, 0.18, 0);

    const ground1 = new BABYLON.Mesh.CreateGround('ground1', 80, 70, 0, scene);
    ground1.position = new BABYLON.Vector3(20,0,-30) 
    ground1.checkCollisions = true;
    ground1.material=greenMaterial;


    //imprort sound
    const ghostSound = new BABYLON.Sound("ghostSound", "https://raw.githubusercontent.com/claudialei/ACG_maze/main/Assets/medieval-fanfare-6826.mp3", scene);
    const ambientSound = new BABYLON.Sound("ghostSound", "https://raw.githubusercontent.com/claudialei/ACG_maze/main/Assets/tense-horror-background-174809.mp3", scene, null, {
        loop: true,
        autoplay: true,
    });

    //createStartingRoom(scene);
    generateMaze();
    drawMaze(scene);

    const xr = await scene.createDefaultXRExperienceAsync({
        floorMeshes: [ground1],
        disableTeleportation: true
    });


    // set up movement
        const featureManager = xr.baseExperience.featuresManager;
        const movementFeature = featureManager.enableFeature(BABYLON.WebXRFeatureName.MOVEMENT, 'latest', {
            xrInput: xr.input,
            // add options here
            movementOrientationFollowsViewerPose: true, // default true
        });

        setupCameraForCollisions(xr.input.xrCamera);

    
    


    //check for ghosts
    engine.runRenderLoop(function () {
            var camPos =  scene.getCameraByName('webxr').getFrontPosition(0.9); 
            for (let i = 0; i < ghostId.length; i++){
                    if (((camPos.x > ghostPos[i].x1 && camPos.x < ghostPos[i].x2 && camPos.z > ghostPos[i].z1 && camPos.z < ghostPos[i].z2)) && !scene.getMeshByName(ghostId[i]).isEnabled()){  //
                        scene.getMeshByName(ghostId[i]).setEnabled(true);
                        ghostSound.play();
                    }
            }
    
        scene.render();
    })

    return scene;
};

window.initFunction = async function () {
        var asyncEngineCreation = async function () {
            try {
                return createDefaultEngine();
            } catch (e) {
                console.log("the available createEngine function failed. Creating the default engine instead");
                return createDefaultEngine();
            }
        }

        window.engine = await asyncEngineCreation();
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = createScene();
    };
    initFunction().then(() => {
        scene.then(returnedScene => {
            sceneToRender = returnedScene;
        });

    });

    // Resize
    window.addEventListener("resize", function () {
        engine.resize();
    });


//maze
let maze;
let mazeX = 10;
let mazeY = 9;
let visited = 0;
let steps= 1000000;
let cell =[];
var notStarted = true;
var size = 2; //changes the maze scale

function drawMaze(scene){

    const stoneTexture = new BABYLON.Texture("https://raw.githubusercontent.com/claudialei/ACG_maze/main/Assets/Rock035_4K-JPG/Rock035_4K-JPG_Color.jpg", scene);
    const mossTexture = new BABYLON.Texture("https://raw.githubusercontent.com/claudialei/ACG_maze/main/Assets/Moss002_4K-JPG/Moss002_4K-JPG_Color.jpg", scene);
    const stoneBump = new BABYLON.Texture("https://raw.githubusercontent.com/claudialei/ACG_maze/main/Assets/Rock035_4K-JPG/Rock035_4K-JPG_NormalDX.jpg", scene)
    const mossBump = new BABYLON.Texture("https://raw.githubusercontent.com/claudialei/ACG_maze/main/Assets/Moss002_4K-JPG/Moss002_4K-JPG_NormalDX.jpg", scene)

    const brickTex = new BABYLON.Texture("https://raw.githubusercontent.com/claudialei/ACG_maze/main/Assets/Rocks011_1K-PNG/Rocks011_1K-PNG_Color.png",scene)
    const brickBump = new BABYLON.Texture("https://raw.githubusercontent.com/claudialei/ACG_maze/main/Assets/Rocks011_1K-PNG/Rocks011_1K-PNG_NormalDX.png",scene)

    const borderMat = new BABYLON.StandardMaterial("borderMat", scene);
    borderMat.diffuseTexture = brickTex//stoneTexture;
    borderMat.bumpTexture = brickBump//stoneBump;
    //borderMat.specularPower = 0;
    borderMat.specularColor = new BABYLON.Color3(0, 0, 0);
    borderMat.invertNormalMapX = true;
    borderMat.invertNormalMapY = true;

    const mazeMat = new BABYLON.StandardMaterial("mazeMat", scene);
    mazeMat.diffuseTexture = brickTex//mossTexture;
    mazeMat.bumpTexture = brickBump//mossBump
    mazeMat.specularColor = new BABYLON.Color3(0, 0, 0);
    //mazeMat.specularPower = 0;
    mazeMat.invertNormalMapX = true;
    mazeMat.invertNormalMapY = true;

    //ghost material
    var ghostMat = new BABYLON.StandardMaterial("ghostMat", scene);
    ghostMat.diffuseTexture = new BABYLON.Texture("https://raw.githubusercontent.com/claudialei/ACG_maze/main/Assets/ghost.png", scene);
    ghostMat.diffuseTexture.hasAlpha = true;


    //boders
    for (let i =0; i < maze.length+2; i++){

        let box1 = BABYLON.MeshBuilder.CreateBox("box", {width: size, depth:size, height: 3}, scene);
        box1.position = new BABYLON.Vector3(i*size, 1.5, 0);
        box1.material = borderMat;
        box1.checkCollisions = true;
        if(i!==0){      //leaves entrance to maze
            let box2 = BABYLON.MeshBuilder.CreateBox("box", {width: size, depth:size, height: 3}, scene);
            box2.position = new BABYLON.Vector3(0,1.5,(-i-1)*size);
            box2.material = borderMat;
            box2.checkCollisions = true;
            
        }
        let box3 = BABYLON.MeshBuilder.CreateBox("box", {width: size, depth:size, height: 3}, scene);
        box3.position = new BABYLON.Vector3((maze.length+1)*size, 1.5, (-i-1)*size);
        box3.material = borderMat;
        box3.checkCollisions = true;
        let box4 = BABYLON.MeshBuilder.CreateBox("box", {width: size, depth:size, height: 3}, scene);
        box4.position = new BABYLON.Vector3(i*size,1.5,(-maze.length-3)*size);
        box4.material = borderMat;
        box4.checkCollisions = true;

        
        
    }

    var i = 0;
    //maze
    for (let r = 0; r < maze.length; r++) {
    for (let c = 0; c < maze[0].length; c++) {
      if (maze[r][c]){
        if (!((r == 4 && c == maze.length+1) || (r == maze.length-1 && c == 5))){
            let box = BABYLON.MeshBuilder.CreateBox("box", {width: size, depth:size, height: 3}, scene);
            box.position = new BABYLON.Vector3((r + 1)*size, 1.5, -(c + 1)*size);
            box.material = mazeMat;
            box.checkCollisions = true;
            }
        }else{
            var rand = Math.random();
            if (rand < 0.12){
                ghostId[i] = "ghost" + i.toString();
                let ghost = BABYLON.MeshBuilder.CreatePlane(ghostId[i], {size: 1.5})
                ghost.position = new BABYLON.Vector3((r + 1)*size, 2, -(c + 1)*size);
                ghost.setEnabled(false);;
                ghost.billboardMode = BABYLON.Mesh.BILLBOARDMODE_Y;
                ghost.material = ghostMat;
                ghostPos[i]= {x: ghost.position.x, x1:ghost.position.x-1, x2:ghost.position.x+1, z:ghost.position.z, z1:ghost.position.z-1, z2:ghost.position.z+1}
                i++;
            }
        }
      }
    }
    
  
    if ((visited < mazeX * mazeY) && (--steps > 0)) drawMaze();
    console.log(maze.length);

    

}

function generateMaze(){
    if (maze != null) return
  setUp();
  
  
  while ((visited < mazeX*mazeY) && (--steps > 0)){
    //pick random neighbour
    let nl = [];
    if(cell.r+2 < maze.length) nl.push({r:cell.r+2, c:cell.c});
    if(cell.c+2 < maze[0].length) nl.push({r:cell.r, c:cell.c+2});
    if (cell.r > 0) nl.push({r:cell.r-2, c:cell.c});
    if (cell.c>0) nl.push({r:cell.r, c:cell.c-2});
    let n = nl[Math.floor(Math.random()*nl.length)];
    if(maze[n.r][n.c] == 1){ //unvisited
      maze[n.r][n.c]  = 0;  //visted
      maze[(n.r+cell.r)/2][(n.c+cell.c)/2] = 0; //remove wall
      visited++
    }
    cell = n;
  }
}

function setUp(){
  // init maze
  maze = Array(mazeY*2-1).fill().map(()=> Array(mazeX*2-1));
  for (let r = 0; r < mazeY*2-1; r++){
    for (let c = 0; c < mazeX*2-1; c++){
      maze[r][c]=1;      
    }
  }
  
  //pick a start point
  cell = {r:0, c:0};
  maze[cell.r][cell.c]=0;  //set to 1 == wall
  
}

function createStartingRoom(scene){

    //create starting room with instructions and objective
}



                window.initFunction = async function() {
                    
                    
                    
                    var asyncEngineCreation = async function() {
                        try {
                        return createEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = createScene();};
        initFunction().then(() => {scene.then(returnedScene => { sceneToRender = returnedScene; });
                            
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>
